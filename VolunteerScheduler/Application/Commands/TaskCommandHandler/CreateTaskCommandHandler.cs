using MediatR;
using VolunteerScheduler.Application.Interfaces;
using VolunteerScheduler.Domain.Entities;
using VolunteerScheduler.Infrastructure.Repositories;

namespace VolunteerScheduler.Application.Commands.TaskCommandHandler
{
    public record CreateTaskCommand(string Title, DateTime Start, DateTime End, int NumberOfOpenSlots, int CreatedByTeacherId) : IRequest<int>;

    public class CreateTaskCommandHandler : IRequestHandler<CreateTaskCommand, int>
    {
        private readonly ITaskRepository _repo;

        public CreateTaskCommandHandler(ITaskRepository repo)
        {
            _repo = repo;
        }

        public async Task<int> Handle(CreateTaskCommand request, CancellationToken cancellationToken)
        {

            if (request.Start >= request.End)
                throw new ArgumentException("Task start time must be before end time.");

            if(request.Start <= DateTime.Now || request.End <= DateTime.Now)
                throw new ArgumentException("Task start and end times must be in the future.");

            var task = new VolunteerTask
            {
                // Id will be generated by DB
                Title = request.Title,
                Start = request.Start,
                End = request.End,
                NumberOfAvailableSlots = request.NumberOfOpenSlots,
                CreatedByTeacherId = request.CreatedByTeacherId,
                ParticipatingParents = new List<int>()
            };

            await _repo.AddAsync(task, cancellationToken);

            // Assuming AddAsync sets the Id on task after saving
            return task.Id;
        }
    }
}
